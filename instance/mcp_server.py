from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Dict, Any, Optional
import json
import pymysql
from datetime import datetime, timedelta
import pandas as pd
import numpy as np
from pathlib import Path
import os
from dotenv import load_dotenv

# Garantir carregamento do .env na raiz do projeto, mesmo executando a partir de instance/
ROOT_ENV = Path(__file__).resolve().parents[1] / '.env'
load_dotenv(dotenv_path=str(ROOT_ENV))
app = FastAPI(title="FinanMaster MCP", version="1.0.0")

# Configurar CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Modelos Pydantic
class ReportRequest(BaseModel):
    report_type: Optional[str] = "financial"
    period: Optional[str] = "current_month"
    categories: Optional[List[str]] = None
    insights: bool = True
    user_id: Optional[int] = None

class ReportResponse(BaseModel):
    report_type: str
    data: Dict[str, Any]
    insights: List[str]
    recommendations: List[str]
    generated_at: str

class AIAgentRequest(BaseModel):
    query: str
    context: Optional[Dict[str, Any]] = None
    user_id: Optional[int] = None

class AIAgentResponse(BaseModel):
    response: str
    actions: List[Dict[str, Any]]
    confidence: float

# Configura√ß√£o do banco de dados (MySQL, mesmo .env do app Flask)
DB_HOST = os.getenv("DB_HOST", "127.0.0.1")
DB_PORT = int(os.getenv("DB_PORT", "3306"))
DB_USER = os.getenv("DB_USER", "root")
DB_PASSWORD = os.getenv("DB_PASSWORD", "")
DB_NAME = os.getenv("DB_NAME", "finanmaster")

def get_db_connection():
    """Cria conex√£o com o banco de dados MySQL"""
    return pymysql.connect(
        host=DB_HOST,
        port=DB_PORT,
        user=DB_USER,
        password=DB_PASSWORD,
        database=DB_NAME,
        charset="utf8mb4",
        autocommit=True,
        cursorclass=pymysql.cursors.Cursor,
    )

def execute_query(query: str, params: tuple = ()) -> List[tuple]:
    """Executa query no banco de dados"""
    conn = get_db_connection()
    try:
        with conn.cursor() as cursor:
            cursor.execute(query, params)
            results = cursor.fetchall()
            return results
    finally:
        conn.close()

# Mensagem padr√£o quando n√£o h√° dados
def no_data_message() -> str:
    return (
        "üìù Voc√™ ainda n√£o possui dados cadastrados neste per√≠odo.\n\n"
        "Para come√ßar a gerar insights:\n"
        "‚Ä¢ Adicione sua primeira transa√ß√£o (Receita ou Despesa)\n"
        "‚Ä¢ Defina um or√ßamento e metas financeiras\n\n"
        "Posso abrir o formul√°rio de nova transa√ß√£o para voc√™ agora."
    )

def get_transactions_data(period: str = "current_month", user_id: Optional[int] = None) -> pd.DataFrame:
    """Obt√©m dados de transa√ß√µes como DataFrame (filtragem de per√≠odo feita em pandas para evitar diferen√ßas de timezone)."""
    params: List[Any] = []
    query = (
        "SELECT description, value, category, `type`, `date`, created_at, user_id "
        "FROM transactions"
    )
    if user_id is not None:
        query += " WHERE user_id = %s"
        params.append(user_id)
    query += " ORDER BY `date` DESC"

    try:
        results = execute_query(query, tuple(params))
        if not results:
            return pd.DataFrame(columns=['description', 'value', 'category', 'type', 'date', 'created_at'])

        df = pd.DataFrame(results, columns=['description', 'value', 'category', 'type', 'date', 'created_at', 'user_id'])
        df['date'] = pd.to_datetime(df['date'], errors='coerce')
        df['value'] = pd.to_numeric(df['value'], errors='coerce')
        df = df.dropna(subset=['date'])

        now = pd.Timestamp.now()
        if period == 'current_month':
            df = df[(df['date'].dt.year == now.year) & (df['date'].dt.month == now.month)]
        elif period == 'last_3_months':
            df = df[df['date'] >= now - pd.DateOffset(months=3)]
        elif period == 'last_6_months':
            df = df[df['date'] >= now - pd.DateOffset(months=6)]

        return df[['description', 'value', 'category', 'type', 'date', 'created_at']]
    except Exception as e:
        print(f"Erro ao obter dados: {e}")
        return pd.DataFrame(columns=['description', 'value', 'category', 'type', 'date', 'created_at'])

def generate_insights(df: pd.DataFrame) -> List[str]:
    """Gera insights baseados nos dados"""
    insights = []
    
    if df.empty:
        insights.append("Nenhuma transa√ß√£o encontrada no per√≠odo selecionado.")
        return insights
    
    # An√°lise de receitas vs despesas
    receitas = df[df['type'] == 'Receita']['value'].sum()
    despesas = df[df['type'] == 'Despesa']['value'].sum()
    saldo = receitas - despesas
    
    insights.append(f"Receitas totais: R$ {receitas:,.2f}")
    insights.append(f"Despesas totais: R$ {despesas:,.2f}")
    insights.append(f"Saldo: R$ {saldo:,.2f}")
    
    if saldo > 0:
        insights.append("‚úÖ Saldo positivo - suas finan√ßas est√£o saud√°veis!")
    else:
        insights.append("‚ö†Ô∏è Saldo negativo - considere reduzir despesas ou aumentar receitas.")
    
    # An√°lise de categorias
    if not df[df['type'] == 'Despesa'].empty:
        despesas_categoria = df[df['type'] == 'Despesa'].groupby('category')['value'].sum()
        maior_categoria = despesas_categoria.idxmax()
        maior_valor = despesas_categoria.max()
        
        insights.append(f"Maior categoria de despesa: {maior_categoria} (R$ {maior_valor:,.2f})")
        
        # Identificar categorias com gastos altos
        media_despesas = despesas_categoria.mean()
        categorias_altas = despesas_categoria[despesas_categoria > media_despesas * 1.5]
        if len(categorias_altas) > 0:
            insights.append(f"‚ö†Ô∏è Categorias com gastos acima da m√©dia: {', '.join(categorias_altas.index)}")
    
    # An√°lise temporal
    if len(df) > 1 and 'date' in df.columns and df['date'].dtype.name.startswith('datetime'):
        try:
            df_copy = df.copy()
            df_copy["month"] = df_copy["date"].dt.to_period("M").astype(str)
            gastos_mensais = df_copy[df_copy['type'] == 'Despesa'].groupby('month')['value'].sum()
            
            if len(gastos_mensais) > 1:
                tendencia = gastos_mensais.iloc[-1] - gastos_mensais.iloc[-2]
                if tendencia > 0:
                    insights.append("üìà Tend√™ncia de aumento nos gastos mensais")
                else:
                    insights.append("üìâ Tend√™ncia de redu√ß√£o nos gastos mensais")
        except Exception as e:
            print(f"Erro na an√°lise temporal: {e}")
            pass
    
    return insights

def generate_recommendations(df: pd.DataFrame) -> List[str]:
    """Gera recomenda√ß√µes baseadas nos dados"""
    recommendations = []
    
    if df.empty:
        recommendations.append("Comece registrando suas primeiras transa√ß√µes para obter insights personalizados.")
        return recommendations
    
    receitas = df[df['type'] == 'Receita']['value'].sum()
    despesas = df[df['type'] == 'Despesa']['value'].sum()
    saldo = receitas - despesas
    
    # Recomenda√ß√µes baseadas no saldo
    if saldo < 0:
        recommendations.append("üí° Considere criar um or√ßamento mensal para controlar gastos")
        recommendations.append("üí° Identifique despesas desnecess√°rias que podem ser reduzidas")
        recommendations.append("üí° Procure formas de aumentar suas receitas (freelance, investimentos)")
    
    # Recomenda√ß√µes baseadas em categorias
    if not df[df['type'] == 'Despesa'].empty:
        despesas_categoria = df[df['type'] == 'Despesa'].groupby('category')['value'].sum()
        maior_categoria = despesas_categoria.idxmax()
        
        if maior_categoria in ['Lazer', 'Alimenta√ß√£o']:
            recommendations.append(f"üéØ Considere reduzir gastos em {maior_categoria} para economizar mais")
        
        if 'Moradia' in despesas_categoria and despesas_categoria['Moradia'] > receitas * 0.3:
            recommendations.append("üè† Gastos com moradia est√£o altos (>30% da receita). Considere alternativas.")
    
    # Recomenda√ß√µes gerais
    recommendations.append("üìä Mantenha o registro regular de todas as transa√ß√µes")
    recommendations.append("üéØ Defina metas financeiras espec√≠ficas e acompanhe o progresso")
    recommendations.append("üí∞ Considere investir parte do saldo em aplica√ß√µes financeiras")
    
    return recommendations

@app.get("/")
async def root():
    """Endpoint raiz do MCP"""
    return {
        "message": "FinanMaster MCP - Sistema de Relat√≥rios Inteligentes",
        "version": "1.0.0",
        "endpoints": {
            "/reports/generate": "Gerar relat√≥rios financeiros",
            "/ai/analyze": "An√°lise inteligente com IA",
            "/ai/chat": "Chat com agente IA"
        }
    }

@app.post("/reports/generate", response_model=ReportResponse)
async def generate_report(request: ReportRequest):
    """Gera relat√≥rio financeiro com insights"""
    try:
        # Obter dados
        df = get_transactions_data(request.period, request.user_id)
        # Logs de diagn√≥stico
        print("[MCP] /reports/generate",
              "user_id=", request.user_id,
              "period=", request.period,
              "rows=", 0 if df is None else len(df))
        if df is not None and not df.empty:
            try:
                print("[MCP] first_rows:", df[['description','value','category','type','date']].head(3).to_dict('records'))
            except Exception:
                pass
        
        # Filtrar por categorias se especificado
        if request.categories:
            df = df[df['category'].isin(request.categories)]
        
        # Calcular m√©tricas b√°sicas
        receitas = df[df['type'] == 'Receita']['value'].sum()
        despesas = df[df['type'] == 'Despesa']['value'].sum()
        saldo = receitas - despesas
        
        # Dados por categoria
        if not df.empty:
            despesas_categoria = df[df['type'] == 'Despesa'].groupby('category')['value'].sum().to_dict()
            receitas_categoria = df[df['type'] == 'Receita'].groupby('category')['value'].sum().to_dict()
        else:
            despesas_categoria = {}
            receitas_categoria = {}
        
        # Dados temporais
        if not df.empty and 'date' in df.columns:
            try:
                df_copy = df.copy()
                df_copy['date'] = pd.to_datetime(df_copy['date'], errors='coerce')
                df_copy["month"] = df_copy["date"].dt.to_period("M").astype(str)
                gastos_mensais = df_copy[df_copy['type'] == 'Despesa'].groupby('month')['value'].sum().to_dict()
            except Exception as e:
                print(f"Erro ao processar dados temporais: {e}")
                gastos_mensais = {}
        else:
            gastos_mensais = {}
        
        # Converter DataFrame para lista de dicion√°rios para a tabela
        transactions_list = []
        if not df.empty:
            for _, row in df.iterrows():
                transactions_list.append({
                    "description": str(row['description']),
                    "value": float(row['value']),
                    "category": str(row['category']),
                    "type": str(row['type']),
                    "date": row['date'].isoformat() if pd.notna(row['date']) else None
                })
        
        # Estruturar dados do relat√≥rio
        report_data = {
            "period": request.period,
            "summary": {
                "total_receitas": float(receitas),
                "total_despesas": float(despesas),
                "saldo": float(saldo),
                "num_transactions": len(df)
            },
            "by_category": {
                "despesas": despesas_categoria,
                "receitas": receitas_categoria
            },
            "temporal": {
                "gastos_mensais": gastos_mensais
            },
            "transactions": transactions_list
        }
        
        # Gerar insights e recomenda√ß√µes
        insights = generate_insights(df) if request.insights else []
        recommendations = generate_recommendations(df)
        
        return ReportResponse(
            report_type=request.report_type,
            data=report_data,
            insights=insights,
            recommendations=recommendations,
            generated_at=datetime.now().isoformat()
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erro ao gerar relat√≥rio: {str(e)}")

@app.post("/ai/analyze", response_model=AIAgentResponse)
async def analyze_with_ai(request: AIAgentRequest):
    """An√°lise inteligente com IA"""
    try:
        # Obter dados recentes para contexto
        df = get_transactions_data("current_month", request.user_id)

        # Sem dados -> orientar cadastro
        if df.empty:
            return AIAgentResponse(
                response=no_data_message(),
                actions=[{"type": "prompt_add_data", "data": {}}],
                confidence=0.95
            )
        
        # An√°lise b√°sica baseada na query
        query_lower = request.query.lower()
        response = ""
        actions = []
        confidence = 0.8
        
        # Navega√ß√£o por comandos naturais
        def nav_response(section: str, open_modal: bool = False, text: str = ""):
            txt = text or {
                'transactions': 'Abrindo Transa√ß√µes‚Ä¶',
                'budget': 'Abrindo Or√ßamento‚Ä¶',
                'goals': 'Abrindo Metas‚Ä¶',
                'reports': 'Abrindo Relat√≥rios‚Ä¶',
                'dashboard': 'Indo para o Dashboard‚Ä¶'
            }.get(section, 'Abrindo se√ß√£o‚Ä¶')
            return AIAgentResponse(
                response=txt,
                actions=[{"type": "navigate_to_section", "data": {"section": section, "openModal": open_modal}}],
                confidence=0.95
            )

        if any(k in query_lower for k in ["abrir transa", "nova transa", "lan√ßament", "lancament"]):
            return nav_response('transactions', True, 'Abrindo Transa√ß√µes e o formul√°rio de nova transa√ß√£o‚Ä¶')
        if any(k in query_lower for k in ["abrir or√ßamento", "abrir orcamento", "ver or√ßamento", "ver orcamento", "or√ßamento", "orcamento"]):
            return nav_response('budget', False)
        if any(k in query_lower for k in ["abrir metas", "abrir meta", "ver metas", "ver meta", "metas"]):
            return nav_response('goals', False)
        if any(k in query_lower for k in ["relat√≥rio", "relatorio", "relat√≥rios", "relatorios", "abrir relat"]):
            return nav_response('reports', False)
        if any(k in query_lower for k in ["dashboard", "in√≠cio", "inicio", "home"]):
            return nav_response('dashboard', False)

        if "saldo" in query_lower or "balan√ßo" in query_lower:
            receitas = df[df['type'] == 'Receita']['value'].sum()
            despesas = df[df['type'] == 'Despesa']['value'].sum()
            saldo = receitas - despesas
            
            response = f"Seu saldo atual √© R$ {saldo:,.2f}. "
            if saldo > 0:
                response += "Suas finan√ßas est√£o em ordem! üéâ"
            else:
                response += "Considere revisar seus gastos para equilibrar as contas."
            
            actions.append({
                "type": "show_balance",
                "data": {"saldo": float(saldo), "receitas": float(receitas), "despesas": float(despesas)}
            })
        
        elif "categoria" in query_lower or "gastos" in query_lower or "despesa" in query_lower:
            if not df[df['type'] == 'Despesa'].empty:
                despesas_categoria = df[df['type'] == 'Despesa'].groupby('category')['value'].sum()
                
                # Verificar se perguntou sobre maior ou menor
                if "maior" in query_lower or "mais" in query_lower:
                    maior_categoria = despesas_categoria.idxmax()
                    maior_valor = despesas_categoria.max()
                    
                    response = f"Sua maior categoria de gastos √© {maior_categoria} com R$ {maior_valor:,.2f}. "
                    response += "Considere analisar se esses gastos s√£o realmente necess√°rios."
                    
                    actions.append({
                        "type": "show_category_analysis",
                        "data": {"categoria": maior_categoria, "valor": float(maior_valor)}
                    })
                elif "menor" in query_lower or "menos" in query_lower:
                    menor_categoria = despesas_categoria.idxmin()
                    menor_valor = despesas_categoria.min()
                    
                    response = f"Sua menor categoria de gastos √© {menor_categoria} com R$ {menor_valor:,.2f}. "
                    response += "√ìtimo! Voc√™ est√° controlando bem esses gastos."
                    
                    actions.append({
                        "type": "show_category_analysis",
                        "data": {"categoria": menor_categoria, "valor": float(menor_valor)}
                    })
                else:
                    # Listar todas as categorias
                    response = "Suas categorias de gastos:\n"
                    for categoria, valor in despesas_categoria.items():
                        response += f"‚Ä¢ {categoria}: R$ {valor:,.2f}\n"
                    
                    actions.append({
                        "type": "show_all_categories",
                        "data": dict(despesas_categoria)
                    })
        
        elif "meta" in query_lower or "objetivo" in query_lower:
            # Verificar metas no banco
            goals_query = "SELECT title, target, current FROM goals"
            goals = execute_query(goals_query)
            
            if goals:
                response = "üéØ **Suas Metas Financeiras:**\n\n"
                total_goals = len(goals)
                completed_goals = 0
                
                for goal in goals:
                    title, target, current = goal
                    progress = (current / target) * 100 if target > 0 else 0
                    
                    if progress >= 100:
                        completed_goals += 1
                        response += f"‚úÖ **{title}**: R$ {current:,.2f} / R$ {target:,.2f} (100% - CONCLU√çDA! üéâ)\n\n"
                    elif progress >= 75:
                        response += f"üü¢ **{title}**: R$ {current:,.2f} / R$ {target:,.2f} ({progress:.1f}% - Quase l√°!)\n\n"
                    elif progress >= 50:
                        response += f"üü° **{title}**: R$ {current:,.2f} / R$ {target:,.2f} ({progress:.1f}% - Metade do caminho)\n\n"
                    else:
                        response += f"üî¥ **{title}**: R$ {current:,.2f} / R$ {target:,.2f} ({progress:.1f}% - Come√ßando)\n\n"
                
                # Resumo geral
                completion_rate = (completed_goals / total_goals) * 100
                response += f"üìä **Resumo:** {completed_goals}/{total_goals} metas conclu√≠das ({completion_rate:.1f}%)\n\n"
                
                if completion_rate == 100:
                    response += "üèÜ **Parab√©ns!** Todas as suas metas foram alcan√ßadas! Que tal definir novas metas para continuar evoluindo?"
                elif completion_rate >= 50:
                    response += "üëç **√ìtimo progresso!** Voc√™ est√° no caminho certo. Continue focado!"
                else:
                    response += "üí™ **Vamos l√°!** √â hora de acelerar o ritmo. Foque nas metas mais pr√≥ximas de serem alcan√ßadas."
                    
                actions.append({"type": "show_goals", "data": {"goals": goals, "completion_rate": completion_rate}})
            else:
                response = "üéØ **Voc√™ ainda n√£o definiu metas financeiras!**\n\nTer objetivos claros √© fundamental para o sucesso financeiro. Metas te ajudam a:\n\n‚Ä¢ üìà Manter o foco nos seus objetivos\n‚Ä¢ üí∞ Economizar de forma mais eficiente\n‚Ä¢ üéâ Celebrar conquistas\n‚Ä¢ üìä Medir seu progresso\n\nüí° **Sugest√£o:** Comece com metas pequenas e alcan√ß√°veis, como economizar para uma viagem ou criar uma reserva de emerg√™ncia."
                actions.append({"type": "suggest_goals", "data": {}})
        
        elif "economia" in query_lower or "poupan√ßa" in query_lower or "economizar" in query_lower:
            receitas = df[df['type'] == 'Receita']['value'].sum()
            despesas = df[df['type'] == 'Despesa']['value'].sum()
            economia = receitas - despesas
            
            if economia > 0:
                taxa_economia = (economia / receitas) * 100
                
                if taxa_economia >= 20:
                    response = f"üèÜ **Excelente!** Voc√™ est√° economizando R$ {economia:,.2f} por m√™s ({taxa_economia:.1f}% das receitas).\n\n‚úÖ **Parab√©ns!** Voc√™ est√° no caminho certo para construir uma base financeira s√≥lida.\n\nüí° **Sugest√µes:**\n‚Ä¢ Considere investir parte dessa economia\n‚Ä¢ Mantenha uma reserva de emerg√™ncia\n‚Ä¢ Continue com essa disciplina financeira"
                elif taxa_economia >= 10:
                    response = f"üëç **Muito bom!** Voc√™ est√° economizando R$ {economia:,.2f} por m√™s ({taxa_economia:.1f}% das receitas).\n\n‚úÖ **Bom progresso!** Voc√™ est√° desenvolvendo bons h√°bitos financeiros.\n\nüí° **Para melhorar:**\n‚Ä¢ Tente aumentar essa taxa para 15-20%\n‚Ä¢ Revise gastos desnecess√°rios\n‚Ä¢ Considere fontes de renda extras"
                else:
                    response = f"üìä **Economia atual:** R$ {economia:,.2f} por m√™s ({taxa_economia:.1f}% das receitas).\n\nüîÑ **H√° espa√ßo para melhorar!** Tente economizar pelo menos 10% das suas receitas.\n\nüí° **Dicas para economizar mais:**\n‚Ä¢ Revise assinaturas e servi√ßos\n‚Ä¢ Evite compras por impulso\n‚Ä¢ Use cupons e promo√ß√µes\n‚Ä¢ Compare pre√ßos antes de comprar"
                    
                actions.append({
                    "type": "show_savings_tips",
                    "data": {"economia": float(economia), "taxa": float(taxa_economia)}
                })
            else:
                deficit = abs(economia)
                response = f"‚ö†Ô∏è **Situa√ß√£o cr√≠tica:** Voc√™ est√° gastando R$ {deficit:,.2f} a mais do que recebe.\n\nüö® **A√ß√£o imediata necess√°ria!**\n\nüí° **Estrat√©gias para reverter:**\n‚Ä¢ **Corte gastos:** Revise todas as despesas e elimine o que n√£o √© essencial\n‚Ä¢ **Aumente receitas:** Considere trabalhos extras ou venda de itens\n‚Ä¢ **Reorganize:** Priorize gastos essenciais (alimenta√ß√£o, moradia, sa√∫de)\n‚Ä¢ **Busque ajuda:** Considere consultoria financeira\n\nüéØ **Meta:** Chegar ao equil√≠brio (receitas = despesas) e depois come√ßar a economizar."
                
                actions.append({
                    "type": "show_deficit_analysis",
                    "data": {"deficit": float(deficit), "receitas": float(receitas), "despesas": float(despesas)}
                })
        
        else:
            # Resposta padr√£o sem recurs√£o
            response = "Posso ajudar voc√™ com an√°lises sobre saldo, categorias de gastos, metas financeiras e economia. O que gostaria de saber?"
            actions = []
            confidence = 0.6
        
        return AIAgentResponse(
            response=response,
            actions=actions,
            confidence=confidence
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erro na an√°lise: {str(e)}")

@app.post("/ai/chat", response_model=AIAgentResponse)
async def chat_with_ai(request: AIAgentRequest):
    """Chat interativo com agente IA"""
    try:
        # Obter dados recentes para contexto
        df = get_transactions_data("current_month", request.user_id)

        # Sem dados -> resposta conversacional amig√°vel
        if df.empty:
            return AIAgentResponse(
                response=(
                    "Ol√°! üëã Notei que voc√™ ainda n√£o cadastrou transa√ß√µes.\n\n"
                    "‚Ä¢ Clique em ‚ÄúNova Transa√ß√£o‚Äù para registrar sua primeira receita ou despesa.\n"
                    "‚Ä¢ Depois disso, posso analisar seus gastos, gerar relat√≥rios e sugerir metas.\n\n"
                    "Quer que eu abra o formul√°rio de nova transa√ß√£o?"
                ),
                actions=[{"type": "prompt_add_data", "data": {}}],
                confidence=0.95
            )
        
        # An√°lise mais conversacional baseada na query
        query_lower = request.query.lower()
        response = ""
        actions = []
        confidence = 0.8
        
        # Chat mais natural e conversacional
        if any(word in query_lower for word in ["oi", "ol√°", "hello", "bom dia", "boa tarde", "boa noite"]):
            response = "Ol√°! üëã Sou seu assistente financeiro pessoal. Como posso ajudar voc√™ hoje?"
            confidence = 0.9
            
        elif any(word in query_lower for word in ["como", "est√°", "vai", "situa√ß√£o"]):
            receitas = df[df['type'] == 'Receita']['value'].sum()
            despesas = df[df['type'] == 'Despesa']['value'].sum()
            saldo = receitas - despesas
            
            if saldo > 0:
                response = f"√ìtimo! Sua situa√ß√£o financeira est√° positiva. Voc√™ tem um saldo de R$ {saldo:,.2f}. Continue assim! üí™"
            else:
                response = f"Precisamos dar uma aten√ß√£o especial √†s suas finan√ßas. Seu saldo est√° negativo em R$ {abs(saldo):,.2f}. Vamos trabalhar juntos para melhorar isso! üéØ"
            
            actions.append({
                "type": "show_balance",
                "data": {"saldo": float(saldo), "receitas": float(receitas), "despesas": float(despesas)}
            })
            
        # Comandos naturais de navega√ß√£o no chat
        elif any(k in query_lower for k in ["abrir transa", "nova transa", "lan√ßament", "lancament"]):
            return AIAgentResponse(
                response='Perfeito! Vou abrir Transa√ß√µes e o formul√°rio de nova transa√ß√£o.',
                actions=[{"type": "navigate_to_section", "data": {"section": "transactions", "openModal": True}}],
                confidence=0.95
            )
        elif any(k in query_lower for k in ["abrir or√ßamento", "abrir orcamento", "ver or√ßamento", "ver orcamento", "or√ßamento", "orcamento"]):
            return AIAgentResponse(
                response='Abrindo Or√ßamento.',
                actions=[{"type": "navigate_to_section", "data": {"section": "budget", "openModal": False}}],
                confidence=0.95
            )
        elif any(k in query_lower for k in ["abrir metas", "abrir meta", "ver metas", "ver meta", "metas"]):
            return AIAgentResponse(
                response='Abrindo Metas.',
                actions=[{"type": "navigate_to_section", "data": {"section": "goals", "openModal": False}}],
                confidence=0.95
            )
        elif any(k in query_lower for k in ["relat√≥rio", "relatorio", "report", "an√°lise completa", "analise completa"]):
            # Gerar relat√≥rio completo
            try:
                # Obter dados diretamente
                df = get_transactions_data("all")
                
                # Calcular m√©tricas
                receitas = df[df['type'] == 'Receita']['value'].sum()
                despesas = df[df['type'] == 'Despesa']['value'].sum()
                saldo = receitas - despesas
                
                # Top categorias de despesas
                despesas_categoria = df[df['type'] == 'Despesa'].groupby('category')['value'].sum().sort_values(ascending=False)
                top_categorias = despesas_categoria.head(3)
                
                response = f"""üìä **Relat√≥rio Financeiro Completo**

üí∞ **Resumo Geral:**
‚Ä¢ Total de Receitas: R$ {receitas:,.2f}
‚Ä¢ Total de Despesas: R$ {despesas:,.2f}
‚Ä¢ Saldo Atual: R$ {saldo:,.2f}
‚Ä¢ Total de Transa√ß√µes: {len(df)}

üìà **Principais Categorias de Despesas:**"""
                
                for cat, valor in top_categorias.items():
                    response += f"\n‚Ä¢ {cat}: R$ {valor:,.2f}"
                
                response += "\n\nüí° **Status:** Suas finan√ßas est√£o em ordem! ‚úÖ"
                response += "\nüìã Acesse a se√ß√£o 'Relat√≥rios' para an√°lise detalhada."
                
                confidence = 0.95
                
            except Exception as e:
                response = "Desculpe, ocorreu um erro ao gerar o relat√≥rio. Tente novamente."
                print(f"Erro ao gerar relat√≥rio: {e}")
                
        elif any(word in query_lower for word in ["ajuda", "help", "o que", "posso"]):
            response = """ü§ñ **Ol√°! Sou seu Assistente Financeiro IA**

Posso ajudar voc√™ com:

üí∞ **An√°lises Financeiras**
‚Ä¢ Saldo atual e hist√≥rico
‚Ä¢ Receitas vs Despesas
‚Ä¢ Tend√™ncias mensais

üìä **Categorias e Gastos**
‚Ä¢ Maiores e menores categorias
‚Ä¢ An√°lise por per√≠odo
‚Ä¢ Compara√ß√µes detalhadas

üéØ **Metas e Objetivos**
‚Ä¢ Progresso das suas metas
‚Ä¢ Sugest√µes de economia
‚Ä¢ Planejamento financeiro

üìà **Relat√≥rios Inteligentes**
‚Ä¢ Relat√≥rios completos
‚Ä¢ Insights automatizados
‚Ä¢ Recomenda√ß√µes personalizadas

üí° **Dicas e Conselhos**
‚Ä¢ Estrat√©gias de economia
‚Ä¢ Planejamento de investimentos
‚Ä¢ Controle de gastos

**Como usar:** Digite sua pergunta de forma natural, como:
‚Ä¢ "Qual meu saldo atual?"
‚Ä¢ "Quais s√£o meus maiores gastos?"
‚Ä¢ "Gere um relat√≥rio completo"
‚Ä¢ "Como posso economizar mais?"

O que gostaria de saber? üòä"""
            confidence = 0.9
            
        elif any(word in query_lower for word in ["menor", "menos", "pequeno"]):
            if not df[df['type'] == 'Despesa'].empty:
                despesas_categoria = df[df['type'] == 'Despesa'].groupby('category')['value'].sum()
                menor_categoria = despesas_categoria.idxmin()
                menor_valor = despesas_categoria.min()
                
                response = f"üéâ **Excelente controle!** Sua menor categoria de gastos √© **{menor_categoria}** com R$ {menor_valor:,.2f}. \n\nIsso mostra que voc√™ est√° controlando muito bem esses gastos! Continue assim! üëè\n\nüí° **Dica:** Mantenha esse controle e considere aplicar a mesma disciplina em outras categorias."
                
                actions.append({
                    "type": "show_category_analysis",
                    "data": {"categoria": menor_categoria, "valor": float(menor_valor)}
                })
            else:
                response = "üìù N√£o encontrei despesas registradas para analisar. Que tal come√ßar registrando algumas transa√ß√µes? Isso me ajudar√° a dar insights mais precisos sobre seus gastos!"
                
        elif any(word in query_lower for word in ["maior", "mais", "alto", "grande"]):
            if not df[df['type'] == 'Despesa'].empty:
                despesas_categoria = df[df['type'] == 'Despesa'].groupby('category')['value'].sum()
                maior_categoria = despesas_categoria.idxmax()
                maior_valor = despesas_categoria.max()
                
                # Calcular percentual do total
                total_despesas = despesas_categoria.sum()
                percentual = (maior_valor / total_despesas) * 100
                
                response = f"üîç **An√°lise de Gastos:** Sua maior categoria √© **{maior_categoria}** com R$ {maior_valor:,.2f} ({percentual:.1f}% do total).\n\n"
                
                if percentual > 50:
                    response += "‚ö†Ô∏è **Aten√ß√£o:** Esta categoria representa mais da metade dos seus gastos. Considere revisar se todos esses gastos s√£o realmente necess√°rios.\n\nüí° **Sugest√£o:** Analise cada transa√ß√£o desta categoria e identifique oportunidades de economia."
                elif percentual > 30:
                    response += "üìä **Observa√ß√£o:** Esta categoria tem um peso significativo nos seus gastos. Vale a pena revisar periodicamente.\n\nüí° **Dica:** Considere estabelecer um limite mensal para esta categoria."
                else:
                    response += "‚úÖ **Situa√ß√£o:** Esta categoria est√° em um n√≠vel razo√°vel. Continue monitorando para manter o controle.\n\nüí° **Dica:** Mantenha o foco em n√£o deixar esta categoria crescer descontroladamente."
                
                actions.append({
                    "type": "show_category_analysis",
                    "data": {"categoria": maior_categoria, "valor": float(maior_valor), "percentual": float(percentual)}
                })
            else:
                response = "üìù N√£o encontrei despesas registradas para analisar. Que tal come√ßar registrando algumas transa√ß√µes? Isso me ajudar√° a dar insights mais precisos sobre seus gastos!"
                
        else:
            # Resposta padr√£o sem recurs√£o
            response = "Posso ajudar voc√™ com an√°lises sobre saldo, categorias de gastos, metas financeiras e economia. O que gostaria de saber?"
            actions = []
            confidence = 0.6
        
        return AIAgentResponse(
            response=response,
            actions=actions,
            confidence=confidence
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erro no chat: {str(e)}")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
# Cache buster s√°b 04 out 2025 16:52:00 -03
